#!/usr/bin/env python3

import argparse
import logging
import pprint
import re
import subprocess
import sys
import time

import copr


log = logging.getLogger(__name__)


# This is the list of dist-git packages in the repo. Ordering here
# is also important because it determines build order
PACKAGE_NAMES = [
    "openbios",
    "seabios",
    "sgabios",
    "SLOF",
    "edk2",
    "ipxe",
    "qemu",
    "osinfo-db",
    "libosinfo",
    "libvirt",
    "libvirt-python",
    "virt-manager",
]

# Mapping of package_name:regex for archs to exclude for each package.
# Otherwise copr doesn't take Exc*Arch into account and will report
# build failure
EXCLUDE_ARCH = {
    "edk2": "ppc64",
}


def delay(msg, secs):
    for sec in range(secs):
        newstr = "\r%s(%s of %s)" % (msg, sec + 1, secs)
        sys.stdout.write(newstr)
        sys.stdout.flush()
        time.sleep(1)


class _Copr(object):
    """
    Wrapper class for talking to copr
    """
    def __init__(self):
        self.project_name = "@virtmaint-sig/virt-preview"
        self._client = copr.ClientV2.create_from_file_config()
        self._project = self._client.projects.get_list(
                name="virt-preview", owner="@virtmaint-sig")[0]
        self._chroots = []

    def get_built_verrels(self):
        """
        Ask copr for a list of latest built verrels

        :returns: dict of package_name:verrel
        """
        verrels = {}
        for build in self._project.get_builds():
            if build.state != "succeeded":
                continue
            if build.package_name in verrels:
                continue
            verrel = build.package_name + "-" + build.package_version
            verrels[build.package_name] = verrel

        return verrels

    def get_chroots(self):
        """
        Return the list of chroots used by the project

        :returns: list of strings
        """
        if not self._chroots:
            for chroot in self._project.get_project_chroot_list():
                self._chroots.append(chroot.name)
        return self._chroots


COPR = _Copr()


####################
# Helper functions #
####################

def get_koji_latest_verrels():
    """
    Query koji for the latest verrel build for rawhide of each
        package in PACKAGE_NAMES

    :returns: dict of package_name:verrel
    """
    verrels = {}
    for package_name in PACKAGE_NAMES:
        cmd = ["koji", "latest-build", "--quiet", "rawhide", package_name]
        proc = subprocess.Popen(cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT)
        out, ignore = proc.communicate()
        retcode = proc.wait()
        if retcode != 0:
            print("%s failed with ret=%s: %s" % (cmd, proc.wait(), out))
        verrels[package_name] = out.split()[0].decode("utf-8")

    return verrels


def determine_packages_to_update(koji_verrels, built_verrels):
    """
    Check what packages need updating from latest koji builds compared
    to already built verrels

    :returns: mapping of package_name:short verrel
    """
    need_update = {}
    for package_name, koji_verrel in koji_verrels.items():
        # Split the dist part off the end of the verrel
        built_verrel = built_verrels.get(package_name, '').rsplit(".", 1)[0]
        koji_verrel = koji_verrel.rsplit(".", 1)[0]
        # built_verrel from copr will have epoch, strip it out
        built_verrel = re.sub("-[0-9]+:", "-", built_verrel)

        cmd = ("rpmdev-vercmp %s %s > /dev/null 2>&1" %
                (built_verrel, koji_verrel))

        log.debug("Comparing stripped verrels: built=%s koji=%s",
                built_verrel, koji_verrel)

        if subprocess.getstatusoutput(cmd)[0] == 12:
            need_update[package_name] = koji_verrel

    if not need_update:
        print("Everything is up to date, nothing to build")
    else:
        print("\nThe following packages need updating:\n")
        for p in sorted(need_update):
            print("* %s" % p)

        print()
        delay("Proceeding in 10 seconds, ctrl-c to exit...", 10)
        print()
    return need_update


def build_package(package_name):
    distgiturl = "https://src.fedoraproject.org/rpms/%s" % package_name

    cmd = ["copr-cli", "buildscm", COPR.project_name,
            "--clone-url", distgiturl]
    if package_name in EXCLUDE_ARCH:
        for chroot in COPR.get_chroots():
            if not re.search(EXCLUDE_ARCH[package_name], chroot):
                cmd += ["--chroot", chroot]

    print("\n\n+ %s" % " ".join(cmd))
    returncode = subprocess.call(cmd)
    return bool(returncode == 0)


#########################
# Main and CLI handling #
#########################

def parse_args():
    parser = argparse.ArgumentParser(
        description="Helper for maintaining virt-preview repo")

    parser.add_argument("--rebuild", action="store_true",
            help="Force rebuild for all packages, like when a new chroot "
                 "is added.")
    parser.add_argument("-d", "--debug", action="store_true",
            help="Debug output")

    return parser.parse_args()


def setup_logging(debug):
    global logging
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter(
        "[%(asctime)s] %(levelname)s (%(module)s:%(lineno)d) %(message)s",
        "%H:%M:%S"))
    log.addHandler(handler)
    log.setLevel(debug and logging.DEBUG or logging.ERROR)
    del(logging)


def main():
    options = parse_args()
    setup_logging(options.debug)

    if options.rebuild:
        need_update = PACKAGE_NAMES
    else:
        print("Checking koji for latest rawhide verrels...")
        koji_verrels = get_koji_latest_verrels()
        log.debug("Koji verrels: %s", pprint.pformat(koji_verrels))

        print("Checking copr for latest built verrels...")
        built_verrels = COPR.get_built_verrels()
        log.debug("Built verrels: %s", pprint.pformat(built_verrels))

        need_update = determine_packages_to_update(koji_verrels, built_verrels)

    if not need_update:
        return

    failures = []
    for package_name in PACKAGE_NAMES:
        if package_name not in need_update:
            continue

        build_success = build_package(package_name)
        if not build_success:
            failures.append(package_name)

    if failures:
        print("\n\nTHE FOLLOWING BUILDS FAILED: %s" % failures)
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
