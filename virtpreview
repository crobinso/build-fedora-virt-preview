#!/usr/bin/env python3

import argparse
import datetime
import logging
import pprint
import re
import subprocess
import sys
import time

import copr
import rpm


log = logging.getLogger(__name__)


# This is the list of dist-git packages in the repo. Ordering here
# is also important because it determines build order
PACKAGE_NAMES = [
    "openbios",
    "seabios",
    "SLOF",
    "edk2",
    "ipxe",
    "qemu",
    "osinfo-db",
    "libosinfo",
    "osinfo-db-tools",
    "libvirt",
    "libvirt-python",
    "virt-manager",
]

# Mapping of regex:package_names for packages to exclude per chroot.
# Otherwise copr doesn't take Exc*Arch into account and will report
# build failure
EXCLUDE_ARCH = {
    r".*ppc64.*": ["edk2"],
    r".*aarch64.*": ["openbios"],
}

# If a build is failing, put the package name here and it will be skipped
# for all chroots. Set a cal reminder for a few weeks to check if its building
TEMPSKIP = [
]

# Use when I want to disable some chroots before they go EOL. If
# I remove them entirely then users can't access the content anymore AFAICT
SKIPCHROOTS = [
    r"fedora-28.*",
]


def packages_wanted_for_chroot(chrootname):
    for regex, exclude in EXCLUDE_ARCH.items():
        if re.match(regex, chrootname):
            break
    else:
        exclude = []
    return [p for p in PACKAGE_NAMES if p not in exclude]


def delay(msg, secs):
    for sec in range(secs):
        newstr = "\r%s(%s of %s)" % (msg, sec + 1, secs)
        sys.stdout.write(newstr)
        sys.stdout.flush()
        time.sleep(1)


def _get_all_objects(project, funcname):
    """
    copr get_* apis only return max 100 objects. If we have more than
    that, we need to call the function multiple times with an offset=
    value to scoop them all up
    """
    ret = []
    func = getattr(project, funcname)
    offset = 0
    while True:
        tmp = func(offset=offset)
        ret.extend(tmp)
        if len(tmp) < 100:
            break
        offset += 100
    return ret


def _filter_chroots(chroots):
    ret = []
    for chroot in chroots:
        for skipchrootregex in SKIPCHROOTS:
            if re.match(skipchrootregex, chroot.name):
                break
        else:
            ret.append(chroot)
    return ret


class Copr(object):
    """
    Wrapper class for talking to copr
    """
    PROJECT_NAME = "@virtmaint-sig/virt-preview"

    def __init__(self):
        self._client = copr.ClientV2.create_from_file_config()
        self._project = self._client.projects.get_list(
                name="virt-preview", owner="@virtmaint-sig")[0]

        self._chroots = self._project.get_project_chroot_list()
        self._filtered_chroots = _filter_chroots(self._chroots)
        log.debug("chroot list: %s", [c.name for c in self._chroots])
        log.debug("Filtered chroot list: %s",
                [c.name for c in self._filtered_chroots])
        self._tasks = _get_all_objects(self._project,
                "get_build_tasks")
        self._builds = {b.id: b for b in
                _get_all_objects(self._project, "get_builds")}

        for task in self._tasks:
            if task.state == "running":
                print("Some tasks still in 'running' state. "
                      "not performing any builds.")
                sys.exit(1)

    def _get_latest_builds(self, filter_chroots):
        """
        Ask copr for a list of latest build objects

        :returns: dict of (chroot_name, {package_name: latest_build})
        """
        chroot_buildids = {}
        for task in self._tasks:
            if task.state != "succeeded":
                continue
            if task.chroot_name not in chroot_buildids:
                chroot_buildids[task.chroot_name] = set()
            chroot_buildids[task.chroot_name].add(task.build_id)

        chroot_builds = {}
        chroots = self._chroots
        if filter_chroots:
            chroots = self._filtered_chroots

        for chroot_name in [c.name for c in chroots]:
            builds = {}
            chroot_builds[chroot_name] = builds
            for build_id in reversed(
                    sorted(chroot_buildids.get(chroot_name, []))):
                build = self._builds[build_id]
                if build.package_name in builds:
                    continue
                builds[build.package_name] = build

        return chroot_builds


    def get_built_verrels(self):
        """
        Transpose _get_latest_builds output into a a dict of
        (chroot_name, {package_name: latest verrel})
        """
        chroot_builds = self._get_latest_builds(filter_chroots=True)
        chroot_verrels = chroot_builds.copy()
        for builds in chroot_verrels.values():
            for package_name in list(builds.keys()):
                build = builds[package_name]
                verrel = build.package_name + "-" + build.package_version
                builds[package_name] = verrel
        return chroot_verrels


    def get_old_builds(self):
        chroot_builds = self._get_latest_builds(filter_chroots=False)
        latest_buildids = set()
        for builds in chroot_builds.values():
            for package_name in list(builds.keys()):
                latest_buildids.add(builds[package_name].id)

        old_builds = []
        for build in self._builds.values():
            if build.id in latest_buildids:
                continue

            # Remove old failed/cancelled builds
            if build.state in ["canceled", "failed"]:
                start = datetime.datetime.fromtimestamp(build.submitted_on)
                if (datetime.datetime.now() - start).days < 14:
                    continue
            else:
                # We could do this, will help avoid some issues when
                # subpackages disappear:
                # https://bugzilla.redhat.com/show_bug.cgi?id=1652003
                # But it will also kill access to old builds the second a
                # chroot disappears which is not the most friendly thing.
                continue
            old_builds.append(build.id)

        return old_builds


####################
# Helper functions #
####################

def get_koji_latest_verrels():
    """
    Query koji for the latest verrel build for rawhide of each
        package in PACKAGE_NAMES

    :returns: dict of package_name:verrel
    """
    verrels = {}
    for package_name in PACKAGE_NAMES:
        cmd = ["koji", "latest-build", "--quiet", "rawhide", package_name]
        proc = subprocess.Popen(cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT)
        out, dummy = proc.communicate()
        retcode = proc.wait()
        if retcode != 0:
            print("%s failed with ret=%s: %s" % (cmd, proc.wait(), out))
            sys.exit(retcode)
        verrels[package_name] = out.split()[0].decode("utf-8")

    return verrels


def determine_packages_to_update(koji_verrels, chroot_verrels):
    """
    Check what packages need updating from latest koji builds compared
    to already built verrels
    """
    def _remove_dist(s):
        """
        Strip dist (ex: .fc30) off end of verrel string
        """
        pattern = r"\.fc\d\d"
        if not re.search(pattern, s):
            print("verrel=%s doesn't contain pattern=%s" % (s, pattern))
            sys.exit(1)
        return re.sub(pattern, "", s)

    update_package_chroots = {}
    for package_name, koji_verrel in koji_verrels.items():
        koji_verrel = _remove_dist(koji_verrel)
        need_update = set()

        for chroot_name, built_verrels in chroot_verrels.items():
            if package_name not in packages_wanted_for_chroot(chroot_name):
                continue
            if package_name not in built_verrels:
                need_update.add(chroot_name)
                continue

            built_verrel = _remove_dist(built_verrels[package_name])
            # built_verrel from copr will have epoch, strip it out
            built_verrel = re.sub("-[0-9]+:", "-", built_verrel)

            ver1 = ["1"] + built_verrel.rsplit("-", 1)
            ver2 = ["1"] + koji_verrel.rsplit("-", 1)

            log.debug("Comparing stripped verrels: "
                    "chroot_name=%s built=%s koji=%s", chroot_name, ver1, ver2)
            cmpret = rpm.labelCompare(ver1, ver2)
            if cmpret < 0:
                need_update.add(chroot_name)

        if need_update:
            update_package_chroots[package_name] = need_update

    return update_package_chroots


def build_package(package_name, chroots):
    distgiturl = "https://src.fedoraproject.org/rpms/%s" % package_name

    cmd = ["copr-cli", "buildscm", Copr.PROJECT_NAME,
            "--clone-url", distgiturl]
    for chroot in chroots:
        cmd += ["--chroot", chroot]

    print("\n\n+ %s" % " ".join(cmd))
    returncode = subprocess.call(cmd)
    return bool(returncode == 0)


#########################
# Main and CLI handling #
#########################

def parse_args():
    parser = argparse.ArgumentParser(
        description="Helper for maintaining virt-preview repo")

    parser.add_argument("-d", "--debug", action="store_true",
            help="Debug output")

    return parser.parse_args()


def setup_logging(debug):
    global logging
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter(
        "[%(asctime)s] %(levelname)s (%(module)s:%(lineno)d) %(message)s",
        "%H:%M:%S"))
    log.addHandler(handler)
    log.setLevel(debug and logging.DEBUG or logging.ERROR)
    del(logging)


def build_packages():
    print("Checking koji for latest rawhide verrels...")
    coprapi = Copr()
    print("Checking copr for latest built verrels...")
    chroot_verrels = coprapi.get_built_verrels()
    log.debug("Chroot verrels:\n%s", pprint.pformat(chroot_verrels))

    koji_verrels = get_koji_latest_verrels()
    log.debug("Koji verrels:\n%s", pprint.pformat(koji_verrels))

    update_package_chroots = determine_packages_to_update(
            koji_verrels, chroot_verrels)
    if not update_package_chroots:
        print("Everything is up to date, nothing to build")
        return

    print("\nThe following packages need updating:\n")
    for p in sorted(update_package_chroots):
        print("* %s: %s" % (p, update_package_chroots[p]))

    print()
    delay("Proceeding in 10 seconds, ctrl-c to exit...", 10)
    print()

    failures = []
    for package_name in PACKAGE_NAMES:
        if package_name not in update_package_chroots:
            continue
        if package_name in TEMPSKIP:
            print("TEMPSKIPing package=%s" % package_name)
            continue

        chroots = update_package_chroots[package_name]
        build_success = build_package(package_name, chroots)
        if not build_success:
            failures.append(package_name)

    if failures:
        print("\n\nTHE FOLLOWING BUILDS FAILED: %s" % failures)
        return True


def remove_old_builds():
    coprapi = Copr()
    old_builds = coprapi.get_old_builds()
    if old_builds:
        print("Deleting old cancelled/failed builds...")
    for build_id in old_builds:
        cmd = ["copr-cli", "delete-build", str(build_id)]
        print("+ %s" % " ".join(cmd))
        subprocess.call(cmd)


def main():
    options = parse_args()
    setup_logging(options.debug)

    if build_packages():
        return 1
    remove_old_builds()
    return 0


if __name__ == '__main__':
    sys.exit(main())
